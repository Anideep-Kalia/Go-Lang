Lexer is program that checks your code to ensure you are following grammer or syntax
it is runned before compilation

-> seeding: temporaaly adding data to database just for testing

these are only used for printf
%T => datatype
%v => value  && %+v => for more details && %v# -> showing complex data
%s => to show the values inbetween the string

there is garbage value in this language everything is declared as 0

instead of try and catch in js we have comma ok || err in golang that works just like that

syntax of time in golang is : presenttime.format("01-02-2006 15:04:05 Monday") => this is to format the time 

checkout more eniroment options my command : go env

so if we want to make exe file for the other os systems we can do that by command
: GOOS="{os_name} go build"  => os_name: {darwin: mac}, {linux and windows respectively}

types of memory allocation: 
new() : allocate memory nut no init ; you will get a memory address ; zeroed storage
make() : allocate memory and init ; you will get memory address ; non zeroed storage

automatic garbage collector: golang has 

pointers: declaration of var or const is a reference to memory and these are stored in memory and sometime when passed to function the copy is passed into the function and not actual value
so to get acutal value inside function we use memory address and not references
the deafult value of pointer is nil

there is inheritance in golang and no concept of super and parent

we neeed to close the request everytime we made a url or http call

example of saving json type data in variable :
jsonDataFromWeb := []byte(`
	{
		"coursename": "ReactJS Bootcamp",
		"Price": 299,
		"website": "LearnCodeOnline.in",
		"tags": ["web-dev","js"]
	}
	`)


Modules: the main thing about modules in golang is all the modules are stored in cache or downloaded at the time of use from intrernet so no node_modules
-> Go Mod commands
> mux: like express commands: go -u gitHub.com/gorilla/mux   => will show indirect that means it is using rn so to remove this make a file using mux and run go mod tidy => use it carefully as it is expensive
> to get all versions of modules use: "go list -m -versions {name_of_module}"
> go mod graph => pull up graph of which module depends on which {expensive operation again}
> to get all the modules into the local : go mod vendor => it will create folder like node_modules where you can edit the modules as u like
to use the module from vendor use: go run -mod=vendor main.go

> to start with mongo we have preinstalled/setup in file 25monogoapi

> Context in api calls: whenever our golang project is working with the remote servers we use context so that we can define the timeout and stuff like that while working with remote servers
there are different use cases of context here is one
context.background(): when we don't want to pass any value, deadlines so it is never cancelled
context.TODO() : This is used to connect and make a initialised connection between the database


